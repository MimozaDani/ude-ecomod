---
title: "Week 5, Lecture 2.3 Notes"
author: "Jelena H. Pantel"
institute: "University of Duisburg-Essen"
date: "`r file.mtime(knitr::current_input())`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(deSolve)
```

## Class agenda for November 10, 2022
* 1. Please make sure you have read [__Otto & Day Ch3__](./r3_OttoDay_Ch3.pdf), Sections 3.1,3.2,3.4,3.6
* 2. Please make sure you have prepared answers to all questions in [__Reading Guide 2__](./w3_readguide.html) and [__Reading Guide 3__](./w4_readguide.html)
* 3. In class on 03-11-2022, we discussed how to make our own functions, and how to build *for* loops. I built a function to calculate the number of mice in a yard using equation 2.4 from [__Otto & Day Ch2__](./r2_OttoDay_Ch2.pdf):

```{r eval=FALSE}
mice <- function(Nt,d,b,m){
  Nt1 <- (1+b)*(1-d)*Nt + m
  return(Nt1)
}
```
I would like you to create the following plot of mouse population size (N) over time, using the following values for parameters: *d* = 0.7, *b* = 3, *m* = 4, $N_t$ = 42.

```{r echo=FALSE}
## Step 1. Write values for the parameters in the model (and initial values of state variables)
# d - the *fraction* of mice in yard eaten by cat / day --> 0-1
d <- .7
# b - the *number* of mice born per mouse / day --> N (0-infinity)
b <- 3
# m - the *number* of mice arriving in the yard per day --> N (0-infinity)
m <- 4
# N0 - the initial number of mice in the yard when we begin the survey
Nt <- 42

## Step 2. Write a function that will calculate values of number of mice from one time step to the next.
mice <- function(Nt,d,b,m){
  Nt1 <- (1+b)*(1-d)*Nt + m
  return(Nt1)
}

## Step 3. Call the function
#mice(Nt,d,b,m)

## Step 4. Follow the mice population size over some time intervals
# N - a variable where we record the population size over time
N <- Nt

for(i in 1:100){
  Nt1 <- mice(Nt,d,b,m)
  N <- c(N,Nt1)
  Nt <- Nt1
}

#N
#plot(N)
plot(N,xlab="time",ylab="N_mice",pch=19,col="black")
dat <- as.data.frame(N)
dat$time <- as.numeric(rownames(dat))
#library(ggplot2)
#ggplot2::ggplot(dat,aes(time,N)) + geom_point()
```
To do this, you should approach the problem in a few steps:

* Step 1. Save *d*, *b*, *m*, and $N_t$ as their own variables.
* Step 2. Write the *mice* function.
* Step 3. Make sure the function works by calling it one time using the values given in Step 1. It should return a value for $N_{t+1}$ = 54.4.
* Step 4. Create a new variable called *N*, which can hold the values generated by the function.
* Step 5. Write a *for* loop that will take the calculated value of $N_{t+1}$, and use it as the next time step's value of $N_t$. Repeat this for *i* = 100 time steps.
* Step 6. Use R's *plot* function (or you can use ggplot if you like) to plot N over time.

I demonstrate how this can work below. I use a different function as an example, $P(t+1) = \frac{bP(t)}{1+cP(t)}$:

```{r}
# Step 1. Example parameters
b <- 1.7
c <- .15
Pt <- 6

# Step 2. Example equation function
example_equation_function <- function(b,c,Pt){
  Pt1 <- (b*Pt) / (1 + c*Pt)
  return(Pt1)
}

# Step 3. Make sure the function works
Pt1 <- example_equation_function(b,c,Pt)

# Step 4. Create a new variable to hold future values of P
P <- rep(NA,100)

# Step 5. Create a for loop to iteratively calculate P
P[1] <- Pt
for(i in 2:100){
  P[i] <- example_equation_function(b,c,Pt)
  Pt <- P[i]
}

# Step 6. Plot P over time
plot(P,xlab="time",ylab="P",pch=19,col="black")
dat <- as.data.frame(P)
dat$time <- as.numeric(rownames(dat))
library(ggplot2)
ggplot2::ggplot(dat,aes(time,P)) + geom_point()
```